---
layout: post
title: "一个cache miss 的调优过程"
description: "一个cache miss的调优过程"
category: 性能,数据库,cache miss,性能
tags: [性能,数据库,cache miss,性能]
---
前阵子，业务那边说我们的数据库有性能问题。用perf（linux下的性能测试工具）测下来，我们的耗时占了top好几个。  

定位到代码处，有个地方很好解决，sprintf格式化太耗时了，直接用char一个一个的填充。另外几个地方很奇怪，一个结构体里的两个字段，“**访问个字段占了80%多，访问第二个字段却占了0%**”.  

匪夷所思，直接搬了个电脑跑到业务组封闭了。perf工具不但可以看出哪些函数比较耗时，还可以看出哪些地方cache命中率较低（cpu的cache命中率），恰好就是在访问结构体的地方，第一个字段cache命中率极低。  

这样就解释的通了：访问该结构的第一个字段时，发现cache miss。然后就将该结构加载到cache中，访问第二字段的时候，就cache命中咯。  

接下来我脑子中首先就蹦出“内存分配池”，可惜怎么想都不对劲,因为我们内存数据库，数据都是放在内存中，所以再做一次内存分配也无济于事。后来请教了网络群里的几位大大，有如下的回复

> 要高命中率就要知道哪些数据需要做缓存  
> 哪些是热数据



> 其实高级操作系统，基本上都不需要内存池了。如果你需要的是cpu高速缓存的命中率，那么注意内存行对齐，还有内存最好统一分一大块，这样有助于cache预取。  

看到回复的第一感觉“没什么作用”，其实后来琢磨琢磨，还真说的挺对的。后来组长提醒说“跑下业务，分析下内核到底干了啥”，一看吓一跳，对数据库进行select查询时很多where条件都返回false。再用索引分析工具看了下，果然冲突率很高（hash索引）。  

**这就是真相**！数据冲突很高，在查找数据时遍历了很多无用数据，导致每次操作都会访问大量的数据，导致cache满了然后cache miss。表象就是对于数据页的访问命中率极低，因为从宏观角度来讲，每次操作要访问大量的无效数据页才能找到需要的数据，所以命中率极低。  

后来将索引链打散，冲突率降低，cache miss就极低了。

结论：  
（1）在性能调优时，不能直接从问题入手，要先排除比较容易耗时的因素（索引冲突率较高等等）  
（2）导致cache miss的因素有很多，并不仅仅是数据没有放到缓存中，或者，内存访问跳跃性太大等等，操作系统负责对这方面的优化，而且与机器，系统有很大的关系，所以从这方面入手的优化，很难处理。